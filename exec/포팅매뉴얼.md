# [Lip It!] 포팅 매뉴얼

## 목차
1. [**개발 환경**](#개발-환경)

2. [**EC2 포트 번호**](#ec2-포트-번호)

3. [**환경 변수/설정 파일**](#환경-변수)

4. [**배포 시 특이사항**](#배포-시-특이사항)

5. [**CI/CD 구축**](#cicd-구축)

6. [**외부 서비스 API 사용**](#외부-서비스-api-사용)


## [개발 환경]
### Android
```
agp = 8.5.2
kotlin = 2.1.0
composeBom = 2024.04.01
coreKtx = 1.15.0
lifecycleRuntimeKtx = 2.8.7
datastorePreferences = 1.0.0
navigationFragmentKtx = 2.8.6
activityCompose = 1.10.0
composeMaterial = 1.2.1
composeMaterial3 = 1.0.0-alpha32
retrofit = 2.9.0
converterGson = 2.9.0
loggingInterceptor = 4.9.3
kotlinxCoroutinesPlayServices = 1.6.4
junit = 4.13.2
junitVersion = 1.2.1
espressoCore = 3.6.1
appcompat = 1.7.0
constraintlayout = 2.2.0
media3Exoplayer = 1.6.0
horologist = 0.4.8
playServicesWearableVersion = 19.0.0
tiles = 1.1.0
watchfaceComplicationsDataSourceKtx = 1.1.1

compileSdk = 35
minSdk = 26
targetSdk = 34
AndroidStudio = Koala | 2024.1.1 Patch 2
```

### SpringBoot
```
Java = openjdk 17.0.11(Zulu17)
Spring Boot = 3.3.1
IntelliJ = 2024.3.2 (Ultimate Edition)
```

### FastAPI
```
FastAPI = 0.115.6
Python = 3.12.9
Uvicorn = 0.34.0
VSCode = 1.99.0
```

### DB
```
PostgreSQL = 17.4
flyway = 9.22.0
alembic = 1.15.2
```

### Infra
```
Ubuntu = 22.04.5 LTS
Docker = 26.1.3
jenkins = 2.502
nginx = 1.27.4
redis = 7.4.2
```

### AI
```
fastapi = 0.115.12
uvicorn[standard] = 0.34.0
coqui-tts = 0.26.0
python-multipart = 0.0.20
soundfile = 0.13.1
pydub = 0.25.1
boto3 = 1.37.24
nltk = 3.9.1
aiofiles = 24.1.0
python-dotenv = 1.1.0
```

## [EC2 포트 번호]

| Skill | Port |
| --- | --- |
| Jenkins | 9090 |
| Nginx | 80/443 |
| spring-boot | 8080 |
| fastapi | 8000 |
| postgres | 5432 |
| redis | 6379 |


## [환경 변수]
### .env
```
# PostgreSQL 환경 변수
POSTGRES_PROD_URL=postgresql+asyncpg://arizona:ssafyd102@localhost:5432/lipit_db
POSTGRES_PORT=5432
POSTGRES_USER=arizona
POSTGRES_PASSWORD=ssafyd102
POSTGRES_DB=lipit_db
POSTGRES_HOST=localhost

# Spring Boot DB 설정
SPRING_DATASOURCE_DEV_URL=jdbc:postgresql://localhost:5432/lipit_db?useSSL=false&allowPublicKeyRetrieval=true&useUnicode=true
SPRING_DATASOURCE_PROD_URL=jdbc:postgresql://lipit-postgres:5432/lipit_db?useSSL=false&allowPublicKeyRetrieval=true&useUnicode=true
SPRING_DATASOURCE_USERNAME=arizona
SPRING_DATASOURCE_PASSWORD=ssafyd102

# Redis 환경 변수
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_PASSWORD=ssafyd102

# 타임존 설정
TZ=Asia/Seoul

# OpenAI API 키
OPENAI_API_KEY=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

# Pinecone API 키
PINECONE_API_KEY=pcsk_4LXRhV_G7um5bdq89xn8MezZET49ZDRGjD9RgF5PWVbL9XU3Su1L2NYhrQPGKehZbCd3AH
PINECONE_INDEX_DEV=call-history-dev

# AWS S3 API 키
AWS_ACCESS_KEY_ID=AKIAQWHCPSXRK5AX7E62
AWS_SECRET_ACCESS_KEY=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
AWS_REGION=ap-northeast-2
S3_BUCKET_NAME=lip-it
CLOUDFRONT_DOMAIN=dlxayir1dj7sa.cloudfront.net

# GCP Service Account JSON
GOOGLE_APPLICATION_CREDENTIALS=gcp/gcp_service_account.json

# JWT
JWT_SECRET='3]IU#Bnm!ErdaNw83SpolmJ<g:^CW79e9baAR=|kLs-M"RkzT8X%Y0BYf[7PSJG'
JWT_ALGORITHM=HS256

# TTS SERVER
TTS_SERVER_URL=lipit.store
```
### SpringBoot
#### application.yml
```
spring:
  jackson:
    time-zone: ${TZ}

  profiles:
    active: prod

  application:
    name: Lip It

  messages:
    basename: ValidationMessages
    encoding: UTF-8

  jpa:
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        show_sql: true
        format_sql: false
        jdbc:
          time_zone: ${TZ}
    show-sql: true

  sql:
    init:

  servlet:
    multipart:
      enabled: true
      max-file-size: 10MB
      max-request-size: 10MB

  mvc:
    path match:
      matching-strategy: ant_path_matcher

  flyway:
    enabled: false
    baseline-on-migrate: true
    locations: classpath:db/migration

  cache:
    type: none

server:
  servlet:
    context-path: /spring/api
    encoding:
      charset: UTF-8
      enabled: true
      force: true

jwt:
  secret: ${JWT_SECRET}
  #  access-token-expiration: 900000
  access-token-expiration: 86400000
  refresh-token-expiration: 604800000

springdoc: # Swagger
  swagger-ui:
    operationsSorter: method
    tagsSorter: alpha
    default-model-expand-depth: 0
    default-models-expand-depth: -1
```
#### application-dev.yml
```
spring:
    datasource:
      url: ${SPRING_DATASOURCE_DEV_URL}
      username: ${SPRING_DATASOURCE_USERNAME}
      password: ${SPRING_DATASOURCE_PASSWORD}
      driver-class-name: org.postgresql.Driver

    data:
      redis:
        host: localhost
        port: ${REDIS_PORT}
        password: ${REDIS_PASSWORD}
```
#### application-prod.yml
```
spring:
    datasource:
      url: ${SPRING_DATASOURCE_PROD_URL}
      username: ${SPRING_DATASOURCE_USERNAME}
      password: ${SPRING_DATASOURCE_PASSWORD}
      driver-class-name: org.postgresql.Driver

    data:
      redis:
        host: ${REDIS_HOST} # Docker Compose의 서비스명
        port: ${REDIS_PORT}
        password: ${REDIS_PASSWORD}
```
#### Dockerfile
```
FROM openjdk:17-jdk

WORKDIR /app

COPY build/libs/*SNAPSHOT.jar lipit.jar

ENTRYPOINT ["java", "-jar", "lipit.jar"]
```
### FastAPI
#### Dockerfile
```
FROM python:3.12-slim AS builder

WORKDIR /install

RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    gcc \
    libffi-dev \
    libssl-dev \
    curl \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .

RUN pip install --upgrade pip \
    && pip install --prefer-binary --no-cache-dir --prefix=/install -r requirements.txt


FROM python:3.12-slim

WORKDIR /app

COPY --from=builder /install /usr/local

COPY . .

RUN find . -type d -name "__pycache__" -exec rm -r {} + || true

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```
### Docker Compose
#### docker-compose.yml
```
services:

  spring-boot:
    # build:
    #  context: ./spring-boot-app # Spring Boot 프로젝트가 있는 폴더
    #  dockerfile: Dockerfile
    image: itsanisland/lipit-spring-boot
    container_name: lipit-spring-boot
    ports:
      - "8080:8080"
    depends_on:
      - postgres
      - redis
    env_file:
      - .env # .env 파일을 불러오기
    environment:
      - SPRING_DATASOURCE_URL=${SPRING_DATASOURCE_PROD_URL}
      - SPRING_DATASOURCE_USERNAME=${SPRING_DATASOURCE_USERNAME}
      - SPRING_DATASOURCE_PASSWORD=${SPRING_DATASOURCE_PASSWORD}
      - TZ=${TZ}
    restart: always
    networks:
      - app-network

  fastapi:
    # build:
    #  context: ./fastapi-app
    #  dockerfile: Dockerfile
    image: itsanisland/lipit-fastapi
    container_name: lipit-fastapi
    ports:
      - "8000:8000"
    env_file:
      - .env
    environment:
      - POSTGRES_PROD_URI=${POSTGRES_PROD_URI}
    depends_on:
      - postgres
    networks:
      - app-network

  postgres:
    image: postgres:latest
    container_name: lipit-postgres
    env_file:
      - .env
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - TZ={TZ}
    ports:
      - "5432:5432"
    networks:
      - app-network
    volumes:
      - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:latest
    container_name: lipit-redis
    restart: always
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
      - ./redis.conf:/usr/local/etc/redis/redis.conf
    command: [ "redis-server", "/usr/local/etc/redis/redis.conf" ]
    networks:
      - app-network

  nginx:
    image: nginx:latest
    container_name: lipit-nginx
    ports:
      - "80:80"
      - "443:443"
    command: "/bin/sh -c 'while :; do sleep 6h & wait $${!}; nginx -s reload; done & nginx -g \"daemon off;\"'"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./data/certbot/conf:/etc/letsencrypt
      - ./data/certbot/www:/var/www/certbot
    depends_on:
      - spring-boot
    networks:
      - app-network

  certbot:
    image: certbot/certbot
    container_name: lipit-certbot
    volumes:
      - ./data/certbot/conf:/etc/letsencrypt
      - ./data/certbot/www:/var/www/certbot
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"

networks:
  app-network:
    driver: bridge

volumes:
  postgres_data: # Docker 볼륨 선언
  mongo_data:
  redis_data:
    driver: local
  jenkins_home: # 볼륨을 정의하여 Jenkins 설정을 유지
```
#### docker-compose.migrate.yml
```
version: '3.8'

services:
  flyway:
    image: flyway/flyway:10.10
    container_name: flyway-migrate
    command: migrate
    environment:
        FLYWAY_URL: jdbc:postgresql://postgres:${POSTGRES_PORT}/${POSTGRES_DB}
        FLYWAY_USER: ${POSTGRES_USER}
        FLYWAY_PASSWORD: ${POSTGRES_PASSWORD}
    env_file:
      - .env
    depends_on:
      - postgres
    networks:
      - app-network

  alembic:
    image: itsanisland/lipit-fastapi  # FastAPI 이미지를 재활용
    container_name: alembic-migrate
    command: alembic upgrade head
    working_dir: /app
    env_file:
      - .env
    environment:
      - POSTGRES_PROD_URI=postgresql+asyncpg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
    depends_on:
      - postgres
    networks:
      - app-network

networks:
  app-network:
    external: true
```
### Nginx
#### nginx.conf
```
worker_processes auto;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    server {
        listen 443 ssl;
        http2 on;
        server_name j12d102.p.ssafy.io;

        ssl_certificate /etc/letsencrypt/live/j12d102.p.ssafy.io/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/j12d102.p.ssafy.io/privkey.pem;
        include /etc/letsencrypt/options-ssl-nginx.conf;
        ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

        # Spring Boot
        location /spring/api/ {
            proxy_pass http://spring-boot:8080/spring/api/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # rewrite ^/spring(/.*)$ $1 break;
        }

        # FastAPI
        location /fastapi/ {
            proxy_pass http://fastapi:8000/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            rewrite ^/fastapi(/.*)$ $1 break;
        }

        location /fastapi/ws/ {
            proxy_pass http://fastapi:8000/;

            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";

            proxy_set_header Host $host;
            proxy_read_timeout 86400;

            rewrite ^/fastapi/ws/(.*)$ /ws/$1 break;
        }
    }

    server {
        listen 80;
        server_name j12d102.p.ssafy.io www.j12d102.p.ssafy.io;

        location /.well-known/acme-challenge/ {
            root /var/www/certbot;
            allow all;
            autoindex on;
            try_files $uri =404;
        }

        location ~ /\. {
            deny all;
            return 403;
        }

        location / {
            return 301 https://$host$request_uri;
        }
    }
}
```
### Redis
#### redis.conf
```
appendonly yes
appendfilename "appendonly.aof"
save 900 1
save 300 10
```

## [배포 시 특이사항]
### TTS 서버 배포
#### 사용 목적
- SSAFY 지급 노트북의 GPU 사용을 통해 TTS 모델 추론 속도 가속화
(GPU 사양: NVIDIA GeForce RTX 3050 Ti Laptop GPU)
#### 배포 방법
1. Cloudflare 설치(최초 1회 필요) 및 인증
    ```
    # 인증
    cloudflared login

    # ~/.cloudflared/cert.pem 파일 생성 확인
    ```

2. `~/.cloudflared/config.yml` 파일 수정
    ```
    tunnel: lipit-tunnel  # 만든 tunnel 이름
    credentials-file: C:\Users\SSAFY\.cloudflared\e65a037e-18ea-4ab0-89a4-4c2df1bcc5f3.json

    ingress:
      - hostname: lipit.store
        service: http://127.0.0.1:9000  # FastAPI 서버가 실행되는 주소/포트
      - service: http_status:404
    ```

3. Docker Container 실행
    ```
    # Docker Image Pull
    docker pull itsanisland/lipit-tts

    # Docker Image Run
    docker run --name itsanisland/lipit-tts -p 9000:8000 --gpus all lipit-tts
    ```

4. Cloudflare 배포
    ```
    # Tunnel 생성
    cloudflared tunnel create lipit-tunnel

    # 도메인 연결
    cloudflared tunnel route dns lipit-tunnel lipit.store

    # 실행
    cloudflared tunnel run lipit-tunnel
    ```

5. [lipit.store/ws/test](https://lipit.store/ws/test) 테스트 페이지 접속

## [CI/CD 구축]
### Jenkins Credentials
<img src="https://github.com/user-attachments/assets/0af22462-7599-440f-a26b-cfb4f1613d1e"/>

### Pipeline
```
pipeline {
    agent any

    tools {
        gradle 'gradle'
    }

    environment {
        DOCKER_IMAGE_SPRING = "itsanisland/lipit-spring-boot"
        DOCKER_IMAGE_FASTAPI = "itsanisland/lipit-fastapi"
        DOCKER_TAG = "latest"
        EC2_IP = "172.26.4.33"
        PROJECT_DIR = "/home/ubuntu/lipit"
        BACKEND_DIR = "./backend"
        BACKEND_SPRING_DIR = "./backend/spring-boot-app"
        BACKEND_FASTAPI_DIR = "./backend/fastapi-app"
    }

    stages {
        stage('Checkout Code') {
            steps {
                git credentialsId: 'ssafy-gitlab', 
                    branch: 'develop-back', 
                    url: 'https://lab.ssafy.com/s12-ai-image-sub1/S12P21D102.git'
            }
        }

        stage('Prepare Firebase Key') {
            steps {
                withCredentials([file(credentialsId: 'firebase-credentials', variable: 'FIREBASE_KEY_PATH')]) {
                    script {
                        sh '''
                          mkdir -p ${BACKEND_SPRING_DIR}/src/main/resources/firebase
                          rm -f ${BACKEND_SPRING_DIR}/src/main/resources/firebase/firebase_service_key.json
                          cp ${FIREBASE_KEY_PATH} ${BACKEND_SPRING_DIR}/src/main/resources/firebase/firebase_service_key.json
                          echo "✅ Firebase Key 파일 복사 완료"
                        '''
                    }
                }
            }
        }
        
        stage('Prepare GCP Key') {
            steps {
                withCredentials([file(credentialsId: 'gcp-credentials', variable: 'GCP_KEY_PATH')]) {
                    script {
                        sh '''
                          mkdir -p ${BACKEND_FASTAPI_DIR}/gcp
                          rm -f ${BACKEND_FASTAPI_DIR}/gcp/gcp_service_account.json
                          cp ${GCP_KEY_PATH} ${BACKEND_FASTAPI_DIR}/gcp/gcp_service_account.json
                          echo "✅ GCP Key 파일 복사 완료"
                        '''
                    }
                }
            }
        }

        stage('Build JAR') {
            steps {
                dir(BACKEND_SPRING_DIR) {
                    sh '''
                    chmod +x ./gradlew
                    ./gradlew clean build \
                    -DOPENAI_API_KEY="${OPENAI_API_KEY}" \
                    -Dspring.profiles.active=prod \
                    --no-build-cache -x check

                    echo "✅ 빌드 완료"
                    ls -la build/libs/
                    '''
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    def DOCKER_SPRING_BUILD_CMD = "docker build -t ${DOCKER_IMAGE_SPRING}:${DOCKER_TAG} ${BACKEND_SPRING_DIR}"
                    sh DOCKER_SPRING_BUILD_CMD
                    
                    def DOCKER_FASTAPI_BUILD_CMD = "docker build -t ${DOCKER_IMAGE_FASTAPI}:${DOCKER_TAG} ${BACKEND_FASTAPI_DIR}"
                    sh DOCKER_FASTAPI_BUILD_CMD
                }
            }
        }

        stage('Push to Docker Hub') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'docker-hub-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                    sh '''
                        echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin
                        docker push ${DOCKER_IMAGE_SPRING}:${DOCKER_TAG}
                        docker push ${DOCKER_IMAGE_FASTAPI}:${DOCKER_TAG}
                    '''
                }
            }
        }
        
        stage('Run Migration on EC2') {
            steps {
                withCredentials([sshUserPrivateKey(credentialsId: 'ec2-ssh-key', keyFileVariable: 'SSH_KEY_PATH')]) {
                    script {
                        sh '''
                            ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no ubuntu@${EC2_IP} <<EOF
                            cd ${PROJECT_DIR} &&
                            
                            # 마이그레이션 전용 Docker Compose 실행
                            sudo docker-compose -f docker-compose.yml -f docker-compose.migrate.yml rm -fsv postgres flyway alembic &&
                            sudo docker-compose -f docker-compose.yml -f docker-compose.migrate.yml up flyway alembic &&
                            
                            echo "✅ DB 마이그레이션 완료!"
                        '''
                    }
                }
            }
        }


        stage('Deploy to EC2 with Docker Compose') {
            steps {
                withCredentials([sshUserPrivateKey(credentialsId: 'ec2-ssh-key', keyFileVariable: 'SSH_KEY_PATH')]) {
                    script {
                        sh '''
                            ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no ubuntu@${EC2_IP} <<EOF
                            cd ${PROJECT_DIR}  &&
                            
                            # 기존 컨테이너 중지
                            sudo docker-compose down  &&
                            
                            # 최신 이미지 Pull
                            sudo docker pull ${DOCKER_IMAGE_SPRING}:${DOCKER_TAG}  &&
                            
                            sudo docker pull ${DOCKER_IMAGE_FASTAPI}:${DOCKER_TAG} &&
                            
                            # Docker Compose로 컨테이너 실행
                            sudo docker-compose up -d &&
                            
                            # Clean Up Dangling Images
                            sudo docker image prune -f &&
                            
                            echo "✅ 배포 완료!"
                        '''
                    }
                }
            }
        }
    }
}
``` 

## [외부 서비스 API 사용]
- [OpenAI API](https://openai.com/index/openai-api/)

- [Pinecone API](https://app.pinecone.io/)

- [AWS S3](https://aws.amazon.com/ko/s3/)

- [Firebase Cloud Messaging](https://firebase.google.com/docs/cloud-messaging?hl=ko)
